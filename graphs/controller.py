import mysql 
from mysql import connector
from sqlalchemy import create_engine
import os
import pandas as pd
from pandas import ExcelWriter
from pandas import ExcelFile

# Base directory of our project, used to get files 
__base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
# Database variables
__user = 'root'
__passw = 'Cerc2019'
__schema= 'basic'
__host = 'localhost'
__port = '3306'


def createNewTable(pathtofile, tablename): 
    """
    Uses Pandas to read a csv file to a dataframe object and stores it into our database \n
    :param str pathtofile: Path to file from our projects base directory \n
    :param str tablename: Name of the table we wish to input data into. \
    IF tablename exists, it will fail
    """
    df = pd.read_csv(__base+pathtofile)
    
    print("Finished reading csv")
    print(df)
    
    engine = create_engine('mysql+mysqlconnector://'+ __user + ':' + __passw + '@' + __host + ':' + __port + '/' + __schema, echo=False)
    print("Connected to mysql\n")

    # set index_label to id since this is the AutoField generated by django.models 
    df.to_sql(con=engine, name=tablename, if_exists='fail', index=False, index_label = 'index')

def updateTable(pathtofile, tablename):
    """
    Updates a table in our database by appending the new data into the table \n
    :param str pathtofile: Path to file from our projects base directory \n
    :param str tablename: name of table to input data. \n
    IF tablename exists, we will append the data to the bottom \
    OTHERWISE it will create a new table 
    """
    df = pd.read_csv(__base+pathtofile)
    
    print("Finished reading csv")
    print(df)
    
    engine = create_engine('mysql+mysqlconnector://'+ __user + ':' + __passw + '@' + __host + ':' + __port + '/' + __schema, echo=False)
    print("Connected to mysql\n")

    df.to_sql(con=engine, name=tablename, if_exists='append', index=False, index_label = 'index')

def replaceTable(pathtofile, tablename): 
    """
    Uses Pandas to read a csv file to a dataframe object and stores it into our database \n
    :param str pathtofile: Path to file from our projects base directory \n
    :param str tablename: Name of the table we wish to input data into. \n
    IF tablename exists, it will be replaced with the new data
    """
    df = pd.read_csv(__base+pathtofile)
    
    print("Finished reading csv")
    print(df)
    
    engine = create_engine('mysql+mysqlconnector://'+ __user + ':' + __passw + '@' + __host + ':' + __port + '/' + __schema, echo=False)
    print("Connected to mysql\n")

    df.to_sql(con=engine, name=tablename, if_exists='replace', index=False, index_label = 'index')
    
def getBaseData(tablename):
    """
    Reads the raw data and returns it \n
    :param str tablename: Name of table to be opened in our basic db \n
    Returns the dataframe created by pandas of our table    
    """
    engine = create_engine('mysql+mysqlconnector://'+ __user + ':' + __passw + '@' + __host + ':' + __port + '/' + __schema, echo=False)

    df = pd.read_sql_table(con=engine, table_name=tablename)
    return df

def getDateData(tablename, timecol, startdate, enddate):
    """
    Reads raw data according to the date and returns it \n
    :param str tablename: Name of table to be opened \n
    :param str timecol: Name of the Date column \n
    :param DateTime startdate: Start date we want to select data from \n
    :param DateTime enddate: End date we want to select data from \n
    Returns a dataframe of our table 
    """
    engine = create_engine('mysql+mysqlconnector://'+ __user + ':' + __passw + '@' + __host + ':' + __port + '/' + __schema, echo=False)

    #sql query to select specific dates 
    my_query = "SELECT * FROM " + \
                tablename + \
                " WHERE " + timecol + " >= " + "'" + startdate + "'" + \
                " AND " + timecol + " <= "+ "'" + enddate + "'"

    df = pd.read_sql_query(sql = my_query, con=engine)
    return df

def getSingleDateData(tablename, timecol, dateval):
    """
    Reads and returns all the data for a single date 
    :param str tablename: Name of table to be opened \n
    :param str timecol: Name of Date column \n
    :param Datetime dateval: Date to extract data from \n
    Returns a dataframe of our data 
    """
    
    start_date = dateval+' 00:00:00'
    end_date = dateval+' 23:45:00'
    
    # Call the dateData method to create a dataframe for our specified date
    df = getDateData(tablename,timecol,start_date,end_date)
    return df 

def getRecentData(tablename, num_req, col):
    """
    Reads and returns the recent data \n
    :param str tablename: Name of table to be opened \n
    :param int num_req: Number of datapoints to be limited to \n
    :param str col: Name of column in database to be ordered by \n
    Returns a dataframe of our data
    """ 
    engine = create_engine('mysql+mysqlconnector://'+ __user + ':' + __passw + '@' + __host + ':' + __port + '/' + __schema, echo=False)

     #sql query to select specific dates 
    my_query = "SELECT * FROM " + \
                tablename + \
                " ORDER BY " + col + " DESC" + \
                " LIMIT " + str(num_req)
    df = pd.read_sql_query(sql = my_query, con=engine)
    return df

def pandasToJSON(df):
    """
    Converts a dataframe into a JSON string 
    """
    return df.to_json(date_format='iso', orient='split')

def getRecentDataList(num_req):
    """
    Reads and returns a Query list of data from powerdata \n 
    :param int num_req: Number of datapoints to retrieve
    """
    from .models import powerData 
    latest_data_list = powerData.objects.order_by('-Timestamp')[:num_req]
    return latest_data_list

def getMaxData(num_req):
    """
    Gets a list of data points ordered by power consumption \n
    :param int num_req: Number of data points to be extracted \n
    """
    from .models import powerData 
    latest_data_list = powerData.objects.order_by('-Power')[:num_req]
    return latest_data_list

